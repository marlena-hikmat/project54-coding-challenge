/**
 * Creates an infinite, dynamic, and stateful trap for the target object until a specific value 
 * in the property chain is set set by the caller.
 * @returns {Proxy}
 */
function proxyFactory(target = function topProxy(){ /** global object proxy */ }) {
    function innerProxy(){ /** proxy created by get or apply traps */ };
    return new Proxy(target, {
        apply(target) {
            const stateful = {};
            Array.from(Object.getOwnPropertyNames(target)).forEach(name => {
                if(name) stateful[name] = target[name];
            });
            // return proxy of a function that also maintains properties already set
            const statefulProxy = proxyFactory(Object.assign(
                innerProxy, 
                Object.getOwnPropertyNames(stateful).reduce((prev, curr) => {
                    if(curr){
                        // copy only stateful properties that are also writable innerProxy function (object)
                        const d = Object.getOwnPropertyDescriptor(innerProxy, curr);
                        if(!d || d.writable){
                            prev[curr] = stateful[curr];
                        }
                    }

                    return prev;
                }, {})
            ));

            return statefulProxy;
        },
        get(target, prop) {
            target[prop] = target[prop] || proxyFactory(innerProxy);

            return target[prop];
        },
        set(target, prop, value) {
            target[prop] = value;

            return target;
        },
        getPrototypeOf() { // workaround for Proxy type inspection which can't be done natively
            return { name: 'proxy' }
        }
    })
}

/**
 * 
 * @param {Object<string, Array<string>>} obj object whose values will be created as Proxy traps and returned
 * @returns {object<string, Proxy>}
 */
function proxify(obj) {
    return Object.values(obj).reduce((prev, curr) => {
        if (curr) {
            curr.forEach(global => prev[global] = proxyFactory());
        }

        return prev;
    }, {});
}

/**
 * Returns a proxy for numerous AppsScript globals
 * @param {...string|Object<string, Array<string>} filters restricts the globals added to environment; when a string, 
 * the namespaces will be filtered; when an object, the globals within the provided namespaces will be filtered.
 * When in conflict, the most selective filter will be applied. Strings are **CASE SENSITIVE** See example.
 * @returns {...Proxy} infinite proxy traps for the included AppsScript globals
 * @example 
 * // get only the globals for the Sheets and Cache 'namespaces'
 * // 'Sheets' filter will be ignored because the object filter is more selective
 * const globals = require('jest-gas')('Sheets', 'Cache', { Sheets: ['Spreadsheet', 'SpreadsheetApp' ] } );
 * const { Cache, CacheService, Spreadsheet, SpreadsheetApp, Banding } = globals;
 * // here Banding will be undefined because of the selective Sheets filter object
 */
function getGlobals(...filters) {

    if (!filters || filters.length === 0) return proxify(require('./lib/_globals'));

    const filterObj = filters.reduce((prev, curr) => {
        if (curr) {
            if (typeof curr === 'object') {
                Object.entries(curr).forEach(entry => {
                    if (entry) {
                        const [ns, filters] = entry;
                        prev[ns] = filters;
                    }
                });
            }
            if (typeof curr === 'string') prev[curr] = undefined;
        }

        return prev;
    }, {});

    const filteredGlobals = {};

    Object.entries(filterObj).forEach(entry => {
        if (entry) {
            const [ns, /** @type {Array<string>} */ globalFilters] = entry;
            const nsGlobals = require(`./lib/${ns}`);

            filteredGlobals[ns] = globalFilters ? nsGlobals.filter(global => globalFilters.includes(global)) : nsGlobals;
        }
    });

    return proxify(filteredGlobals);
}

module.exports = { getGlobals }